# 进程和线程相关

### 进程和线程的区别

+ 进程是一个正在执行的程序的实例，是系统进行资源调度和分配的基本单位，实现了操作系统的并发；
+ 进程在执行的过程中拥有独立的内存单元，而多个线程共享进程的内存。
+ 进程拥有自己独立的地址空间，某进程内的线程对其他进程不可见。即进程 A 不能通过传地址的方式直接读写进程 B 的存储区域。进程之间需要通过进程间通信（Inter-process communication, IPC)。与之相对的，同一进程的各线程之间可以通过直接传地址或全局变量的方式传递消息。
+ **进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程。** 通常操作系统中运行的一个程序就对应一个线程。在同一进程中，线程的切换不会引起进程的切换。在不同的进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。**相比进程切换，线程切换的开销要小很多。线程与进程互相结合能够提高系统的运行效率。**

#### 线程可以分为两类

+ 用户级线程（user level thread):对于这类线程，油管线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该应用程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个进程中运行，该线程被称为主线程，在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的线程。**用户级线程的好处就是非常高效，不需要进入内核空间，但并发效率不高。
+ 内核级线程（kernel level thread):对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进程线程管理的代码，只能调用内核的线程接口。内核维护进程机器内部的每一个线程，调用也由内核完成。内核级线程的好处是，内核可以讲不同的线程更好地分配到不同的 CPU，以实现真正的并行计算。

**事实上，在现代操作系统中，往往使用组合的方式实现多线程，级线程创建完成在用户空间完成，并且一个应用程序中的多个线程被应到一些内核级线程上，相当于是一种折中的方案。**

### 进程间通信的几种方式

+ 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有有名管道具有管道所具有的所有功能外，它还具有无亲缘关系进程间的通信。管道和有名管道都是一种半双工的通信方式。

+ 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

+ 消息队列：消息队列是消息链接表，存放在内存中并由消息队列标识符标识。消息队列客服了信息传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

+ 共享内存通信：共享内存就是映射一段能被其他进程锁访问的内存，这段内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。

+ 套接子通信：套接子（socket）：套接子也是一种进程间通信的机制，与其他通信机制不同，它可用于不同机器间的进程通信。

+ 信号量：主要作为进程之间及一种进程的不同线程之间的同步和互斥手段。

### 进程同步

多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能会造成系统的混乱。进程同步的任务进程对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和互相合作，保证程序执行的可再现性。

同步机制需要遵循的原则：

1. 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区。
2. 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问。
3. 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等。
4. 让权等待：当进程无法进入临界区的时候，需要释放处理机，边让如忙等。

### 用户态和核心态

![](http://user-gold-cdn.xitu.io/2017/5/22/08d8fe2bdd546e97085f4f1d69281c9f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**当程序运行在 3 级特权级上时，就可以称为用户态**，因为这是低特权级，是普通的用户进程运行特权级，大部分用户直接，，对的程序都是运行在用户态。

反之，**当程序运行在特权级 0 上时，就可以称之为内核态。**

虽然用户态下和内核态下工作的程序是有差别的，当最主要的差别就在于特权级不同，及权利不同。运行在用户态下的程序不能直接访问操作系统内核数据。

当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权利和能力完成的工作时就会切换到内核态。

用户态切换到内核态的 3 中方式：

1. 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序来完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开发的一个中断来实现的，例如 linux 的 0x80 中断。
2. 异常：当 CPU 在执行运行在用户态的程序时，发生了某些不可知的异常，这时会触发由当前运行在进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
3. 外围设备的中断：当外围设备完成用户请求操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先执行的指令是用户态下的指令，那么这个转换自然也就发生了用户态到内核态的转换。比如硬盘读写操作完成，系统会切换到硬盘读写中断处理程序中执行后续的操作等。

### 进程的状态转换

![](https://user-gold-cdn.xitu.io/2017/5/22/412498f4ecd2c25f4294653969aace75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 死锁

死锁产生的必要条件：

1. 互斥条件：进程对锁分配的资源进行排他性的访问。
2. 请求和保持条件：进程被阻塞的时候并不释放申请到的资源。
3. 不可剥夺条件：进程对已经申请到的资源在使用完成之前不可被剥夺。
4. 环路等待条件：发生死锁的时候存在一个进程-资源的环形等待链。

#### 死锁的处理

1. 预防死锁：破换死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格将会降低系统资源的利用率以及吞吐率。
2. 避免死锁：在资源的动态分配中，防止系统进入不安全的状态（可能产生死锁的状态）-如银行家算法。
3. 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大。


# kotlin 中的基本类型

在 kotlin 中，一切皆对象，我们可以调用任何变量的函数或者属性。但是一些类型可以有特殊的内部表示——例如数字、字符、布尔类型可以在运行时表示为原生类型，但是对用户来说，它们看起来就像是普通的类型（有点类型于 Java 中的自动拆装箱）。下面我们会主要说明 Kotlin 中的基本类型：数字、字符、布尔值、数组和字符串。

## 1. 数字

kotlin 提供了一组表示数字的内置类型，对于整数，分别有 byte、short、int、long 4中类型。

|类型|大小|最小值|最大值|
|:---:|:---:|:---|:---|
|Byte|8|-128|127|
|Short|16|-32768|32767|
|Int|32|-2,147,483,648($-2^{31}$)|2,147,483,647($2^{31} - 1$)|
|Long|64|-9,223,372,036,854,775,808($-2^{64}$)|9,223,372,036,854,775,807($2^{63}$-1)|

对于 Kotlin 中整数的自动推断，如果没有超过 `Int` 最大值的初始化变量都会推断为 `Int` 类型。如果超出了其最大值，那么会被推断为 `Long`，如果需要显示指定 `Long` 型值。请在该值后追加 `L` 后缀。

```kotlin
val one  = 1    // Int
val threeBillion = 30000000 // Long
val oneLong = 1L    // Long
val oneByte: Byte = 1   // Byte
```

对于浮点数，Kotlin 提供了 `Float` 和 `Double`。和其他语言一样 Kotlin 遵循 IEE754 标准，`Float` 4 字节，单精度，`Double` 8字节，双精度。

|类型|大小|有效数字比特|指数比特数|十进制位数|
|:--:|:--:|:----:|:---:|:---:|
|Float|32|24|8|6-7|
|Double|64|53|11|15-16|

对于小数的初始化变量，编译器会推断为 `Double`。如果需要将一个值显示的指定为 `Float` 。需要添加 `f` 或者 `F` 后缀。如果这样的值包含多于 6-7 为十进制数，那么会将其设舍入。

```kotlin
val pi = 3.14   // Double
val e = 2.7182818284    // Double
val eFloat = 2.7182818284F  // Float，实际值为 2.7172817
```

## 表示方式

在 java 平台数字的存储类型是 JVM 的原生类型，除非我们需要一个可空的引用（如 `Int?`）或者泛型。后者会把数字自动装箱。

这里需要注意的是在 Kotlin 中，有 `==` 和 `===`，它们的作用分别是：

+ `==` 相当于调用 equals 方法，判断的是值是否相等。
+ `===` 相当于 java 中的 `==` 判断的是对应的引用是否相等。

所以说这里的数字装箱不一定保留同一性。

```kotlin
fun main() {
    val a: Int = 1000
    println(a == a)     // true
    val boxedA: Int? = a // 此时的 boxedA 是一个包装类型
    val anotherBoxedA: Int? = a // 此时的 anotherBoxedA 也是一个包装类型
    println(boxedA === anotherBoxedA)   // false
}
```

> 在 java 中所谓的同一性指的是两个引用ref1和ref2引用了相同的对象或者都是 null，那么表达式ref1==ref2的值为true（在 kotlin 中应该是 ref1 === ref2），就算这两个引用具有不同的类型声明也是如此，否则表达式的值为false。

但另一方面，它保留了相等性：

```kotlin
fun main() {
    val a: Int = 1000
    println(a == a)     // true
    val boxedA: Int? = a // 此时的 boxedA 是一个包装类型
    val anotherBoxedA: Int? = a // 此时的 anotherBoxedA 也是一个包装类型
    println(boxedA == anotherBoxedA)    // true
}
```
# 活动的生命周期

<!-- TOC -->

- [活动的生命周期](#活动的生命周期)
    - [返回栈](#返回栈)
    - [活动状态](#活动状态)
    - [活动的声明周期](#活动的声明周期)

<!-- /TOC -->

## 返回栈

Android 是使用任何 (Task) 来管理活动，一个任务就是一组存放在活动的集合，这个栈也被称为返回栈（Back Stack）。栈是一种后进先出的数据结构，在默认的情况下，每当我们启动了一个新的活动，他会在栈中入栈，并处于栈顶位置。而每当我们按下 Back 键或调用 finish() 方法去销毁活动时，处于栈顶的栈会出栈，这时前一个入栈的活动就会重新处于栈顶位置。系统总是会显式栈顶活动给用户。

![返回栈工作示意图](http://img.mcwebsite.top/20190924182737.png)

## 活动状态

每个活动在其生命周期中最多有四种状态。

1. 运行状态

当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动，因为这会带来非常差的用户体验。

2. 暂停状态

当一个活动处于栈顶位置，但仍然可见，这时活动就进入了暂停状态。你可能会觉得一个活动已经不在栈顶，还怎么会可见呢？这时因为并不是每一个活动都会占满整个屏幕的，比如对话框形式的活动就只会占用屏幕中间的部分区域。处于暂停状态的活动是仍然存活着的，系统也不愿意去回收这种活动（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会考虑回收这种活动。

3. 停止状态

当一个活动不再处于栈顶位置，并不完全可见，就进入了停止状态。系统让然会为这种活动保存响应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。

4. 销毁状态

当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向回收处于这种状态的活动，从而保证手机内存充足。

## 活动的声明周期

Activity 定义了 7 个回调方法，覆盖了活动周期的每一个环节，下面就来一一介绍这 7 个方法。

- OnCreate()。每个活动中都会重新这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件。

- OnStart()。这个方法在活动由不可见变得可见的时候调用。

- OnResume()。这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于可运行的状态。

- OnPause()。这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一个销毁 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响新的栈顶活动的使用。

- OnStop()。这个方法在活动完全不可见的时候调用。它和 onPause() 方法的主要区别在于，如果启动的是一个对话框形式的活动，那么 onPause() 方法会得到执行，而 onStop() 方法并不会执行。

- onDestory()。这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。

- onRestart()。这个方法在活动有停止变为运行状态之前调用，也就是活动被重启了。

以上 7 个方法中处于 onRestart() 方法，其他都是两两成对的，从而有可将活动分为 3 中生存期。

- 完整生存期。活动在 onCreate() 方法和 onDestory() 方法之间所经历的，就是完整的声明周期。一般情况下，一个活动会在 onCreate() 方法中完成各种初始化操作，而在 onDestory() 方法中完成释放内存的操作。

- 可见生存周期。活动在 onStart() 方法和 onStop() 方法之间所经历的，就是可见生存期，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那么对用户可见的资源。比如在 onStart() 方法中对资源进行加载，而在 onStop() 方法中对资源进行释放，从而保证处于停止状态的活动不会占用过多的内存。

- 前台生存期。活动在 onResume() 方法和 onPause() 方法之间经历的就是前台生存期。在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行交互的，我们平时看到和接触最多的就是这个状态下的活动。

为了帮助你能更好的理解，Android 官方提供了一张活动的生命周期示意图，如下图所示：

![活动的生命周期](http://img.mcwebsite.top/20190924193436.png)
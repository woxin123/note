# 传输层协议

传输层的功能

+ 两个主机进行通信实际上就是两个主机中的应用进程互相通信。
+ 应用进程之间的通信被称为端到端的通信。

运输层提供**应用进程间的**逻辑通信。<br>或者说运输层提供**端到端的**逻辑通信。

+ 从通信和信息处理角度看，运输层它上面的应用层提供服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。

![](http://img-blog.csdnimg.cn/20190320205146982.png)

+ 当网络的边缘部分中的两个主机利用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只有用到下三层的功能。

+ 它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。

![](http://img-blog.csdnimg.cn/20190320211400561.png)

## 运输层协议概述

+ 运输层协议和网络协议的主要主要区别

![](http://img-blog.csdnimg.cn/20190320212428544.png)

+ 网络应用对运输服务的要求

![](http://img-blog.csdnimg.cn/20190320212648787.png)

+ 运输层的两个主要协议
    
    为了适应以上两种应用类型：
    + 弹性服务  TCP
        + 数据完整性
    + 多媒体应用  UDP
        + 时延敏感
        + 容忍丢包

+ TCP/IP的运输层有两种不同的协议：
    
    1. 传输控制协议TCP（Transmission Control Protocol）
    2. 用户数据协议UDP（User Datagram Protocol）
    

## 运输层的两个主要协议

+ 当运输层采用面向连接的TCP协议，尽管下面的网络是不可靠的（只提供尽最大努力交付服务），但这种逻辑通信信道就相当于一条双全工的可靠信道。
+ 当运输层采用的无连接的UDP协议时，这种逻辑通信信道是一条不可靠信道。

+ TCP
    + 面向连接服务
    + 可靠数据传送服务
    + 拥塞控制服务
    + 传送的数据单位是TCP报文段

+ UDP
    + 无连接，高效率
    + 传送的数据单位是UDP报文或用户数据包

## 多路复用与多路分解

为了在互联网上找到一台主机上的应用进程，所以就提出了端口的概念。

+ 使用称为“端口”的抽象定位符。
+ 每一个端口有一个端口号，以区分不同端口。
+ 利用全局唯一的一个IP地址标识主机，用本地唯一的端口号来标识这台主机中的进程。
+ 为了区别是TCP还是UDP服务，还要指明运输层协议类型。

三元组（运输层协议、主机IP地址、端口号）能够唯一标识网络中的任何应用进程。

+ 端口实际上是一个抽象的软件结构（包括一些数据结构和I/O缓冲区）。
+ 应用程序（进程）通过系统调用与某端口建立关联（binding）后，相应的应用进程交付给运输层的数据也要通过该端口输出，而运输层交付给该端口的数据都被相应的应用程序所接收。
+ 网络通信是两个进程之间的通信。**两个通信的进程构成一个关联**。
+ 这个关联应该包含**两个三元组**。注意：通信的双方采用的协议应该是相同的。

因此：

五元组（运输层协议、本地主机IP地址、本地端口号、远程主机IP地址、远程端口号）能够描述两个进程的关联。

+ 什么是运输层的多路复用？（源端发送时）
    
    指多个应用进程基于同一个运输层协议发送数据。

+ 什么是运输层的多路分用？（目的端口接收时）
    
    在接收方，有一个运输层协议将报文中的数据交付给不同的应用进程。

    **复用和分用都是通过“端口”来实现的。**
    
+ 端口在进程之间的通信中所起的作用

![](http://img-blog.csdnimg.cn/20190321082417578.png)

### 服务器使用端口号
    + 为了方便客户端定位服务器所在的进程，服务器必须使用周知的端口号（well-known port number）。
    + 每一个标准服务都拥有一个周知端口号。
    + 通常，不同主机上的相同服务器的端口号是相同的。
    + HTTP的默认端口号是80，FTP是21，DNS是53。

### 客户端使用端口号

+ 客户端发起请求时，需提供源和目的的端口号。
+ 目的端口号是客户请求的服务对应的端口号。
+ 客户 进程采用临时端口号，使用时向操作系统申请，由其动态分配，然后该进程再通过系统调用将自己与相应的端口号进行关联操作，使用完成后再交由操作系统管理。

### 端口号类别

1. 周知端口号范围：0~1023，也称为“常用端口号”或“保留端口号”。
2. 注册端口号范围：1024~49151，被保留用作商业性的应用开发。
3. 临时端口号：49152~65535，也称为“动态端口”或“自由端口”。本地系统随机分配。

### 套接字

系统调用接口实际上就是应用进程的控制权和操作系统控制权进行转换的一个接口，即应用编程接口API。

![](http://img-blog.csdnimg.cn/20190321083757993.png)

+ 只要应用程序使用TCP/IP协议进行通信，它就必须通过套接字与操作系统交互。

+ 当应用进程需要使用网络进行通信时就发出系统调用，请求操作系统为其创建“套接字”，以便把网络通信所需要的系统资源分配给该应用进程。
+ 操作系统为这些资源的综合用一个叫做套接字描述符的号码来表示，并把此号码返回给应用进程。应用进程的网络操作都必须通过这个号码。

![](http://img-blog.csdnimg.cn/20190321084325426.png)

+ 通信完毕后，应用进程通过一个关闭套接字的系统调用，通过操作系统回收与该“号码”相关的所有资源。
## UDP协议

UDP是简单的运输层协议。

+ UDP和IP协议一样提供无连接的服务。它在IP的数据报服务之上增加了进程通信的能力。（也就是提供了多路复用和多路分解）
+ UDP 的运行环境应该是在高可靠的网络。
+ 如果运行不在可靠的网络上，则UDP之上的应用程序必须能够解决报文损失，失序等可靠性问题。

UDP协议的特点

+ UDP是无连接的，即发送数据之前不需要建立连接。
+ UDP使用尽最大努力交付，即不保证可靠交付。无须维持复杂的连接状态表。
+ UDP没有拥塞控制，因此网络拥塞不会使源主机的发送速率降低，允许拥塞造成丢失，不允许大时延。

+ UDP是面向报文的
    + 发送方UDP对应用层叫下来的报文，既不合并，也不拆分，而是保留这些报文的边界。
    + 应用层交给UDP的多上的报文，UDP就照样发送，即一次发送一个报文。
    + 接收方UDP对IP层上交的UDP用户数据报，在去除首部后就原封不动地交给上层的应用进程，一次交付一个完整的报文。

![](http://img-blog.csdnimg.cn/20190321093202478.png)

+ UDP支持一对一、一对多、多对一和多对多的交互通信。
+ UDP首部固定8个字节，开销少，处理时延小。

### UDP数据报格式

首部字段有8个字节，由4个字段组成，每个字段都是两字节。

![](http://img-blog.csdnimg.cn/20190321093637643.png)

在计算校验和时，临时把“伪首部”和UDP用户数据报连接在一起，伪首部仅仅是为了计算校验和。

![](http://img-blog.csdnimg.cn/20190321094344481.png)

把临时的“伪首部”和UDP用户数据报按二进制反码运算求和，然后将得出的结果求反码。（在计算校验和的时候，校验和的字段为全0）。

## 面向连接的运输协议TCP

### TCP的特点

1. TCP是面向连接的运输层协议。
    
    在数据传输之前必须建立连接，即在两个通信的TCP进程之间相互确认对方是否存在的并且处于活动状态，同时为两个进程之间的通信协商一些参数并且预留资源（如缓冲区等）。

2. TCP提供可靠交付服务，

    在数据传输过程中，TCP采用的许多方法和手段，如编号确认、流量控制、计时器等，来保证lmjx上提供可靠的传输服务，因此也增加了协议的开销。
    
3. 每一条TCP连接只能有两个端点（endpoint），每一条TCP连接只能是点对点的（一对一）。
4. TCP提供全双工通信。
5. TCP是面向字节流的。

什么是面向字节流：

+ 字节流：是指流入到进程或从进程流出的字节序列。
+ TCP协议把应用层报文看成是一串无结构的字节流。将其分解为多个TCP报文段进行传输，在目的站在重新装配这些段，必要时需要重新发送没有收到的段。
+ TCP不保证接收进程收到的数据块和发送进程的数据块具有对应的大小关系。
+ TCP保证接收进程收到字节流和发送进程发送的字节流完全一致。

TCP可把太长的数据块划分短一些在传送。TCP也可以等待积累足够多的字节后在构成报文段发送出去。

TCP根据接收方给出的窗口值和当前网络拥塞的长度决定一个报文段应该包含多少字节。

![](http://img-blog.csdnimg.cn/20190321143439866.png)

### TCP报文

![](https://img-blog.csdnimg.cn/20190321144325381.png)

+ 源端口和目的端口字段各占2字节。端口是运输层和应用层的服务接口。运输层的复用分用功能都需要端口才能实现。
+ 序号字段——占4个字节，需要范围[0, 2^32 - 1]。TCP连接中传送的数据流中的每一个字节都编上一个序号。
    
    <font color="red">“序号”字段也叫作“报文段序号”字段。其值是报文段数据部分的第一个字节的序号。</font>
    
+ 确认号字段——占四个字节，是期望收到对方的下一个报文段的数据部分的第一个字节的序号。
    
    <font color="red">**确认号等于n，则表明：到序号n-1为止的所有数据都已正确收到。**</font>

+ 数据偏移——占4bit，它指向TCP报文段的数据起始处距离TCP报文段的起始处有多远。“数据偏移”的单位不是字节而是32bit字（4字节为计算单位）。最大值为60字节。
+ 保留字段——占6bit，保留为今后使用，但目前置为0。
+ 紧急比特URG——当URG为1时，表名“紧急指针”字段有效，它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。
+ 紧急指针字段——占16bit。紧急指针之处在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段的最前面）。紧急指针字段定义了一个数，把这个数字加到“序号”上就得出报文段数据部分中嘴巴一个紧急字节。
+ 确认比特ACK——只有当ACK=1时“确认号”字段才有效。当ACK=0时，“确认号”无效。
+ 推送比特PSH(Push)——TCP接收方收到推送比特置1的报文段，就尽快将数据交付给接收进程，而不再等待整个缓存都填满了后再向上交付。
+ 复位比特RST（ReSet）——当RST=1时，表名TCP连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后在重新建立运输连接。也用于拒绝非法的TCP报文段或拒绝连接请求。
+ 同步比特SYN——同步比特SYN置为1，就表示是承恩连接请求或者连接接收的报文。
+ 终止比特FIN（Final）——用来释放一个连接。当FIN=1时，表名此报文段的发送端的数据已发送完毕，并要求释放连接。
+ 窗口字段——占2字节，值范围[0, 2^16 - 1]。窗口指的是发送本报文段的一方的接收窗口（RWin），是让对方设置发送窗口的依据，单位为两个字节。窗口字段明确了出现在允许对方发送的数据量。窗口的值是经常变化的。
+ 校验和——占2字节。检验和字段检验的范围包括首部和数据这两部分。在计算校验和时，也要在TCP报文段前面加上12个字节的伪首部。

![](http://img-blog.csdnimg.cn/20190321153355140.png)

+ TCP选项字段——可变长度
    
    每个选项都包含一个字节的类型字段，用于标识选项的具体类型。
    
TCP 需要掌握的几个选项

+ MSS
+ 窗口扩大因子
+ 时间戳选项

MSS

+ TCP最初职规了一种选项，即最大报文段长度MSS（Maximum Segment Size）。实际上TCP报文段中的数据字段的最大长度。

+ MSS选项只能出现在SYN 标志为1的TCP报文中。
+ 在连接建立阶段，每一方均定义自己在连接期间支持的报文段MSS值，两个方向的该值可以不同。
+ MSS选项占4个字节，其中2字节代表MSS值（0~65535之间），如果某一方没有使用这个选项，默认取值为536字节。
+ 所有Internet主机都要求能够接收536+20=556字节的TCP报文段。

窗口扩大因子

+ 窗口扩大因子——占3个字节，其中有一个字节表示窗口扩大因子S，也称移位值S。

+ 把窗口值向左移动S位后获得实际的窗口大小：

    <font color="red">实际窗口值=首部定义的窗口值*2^S。</font>
    
+ 虽然窗口扩大因子S占了一个字节，但是TCP只允许S最大取14，这就表示最大窗口可以是2^16字节×2^14字节=2^30字节。
+ 窗口扩大因子S只能在双方TCP连接建立阶段协商确定，在连接期间它的值不能被改变。

TCP的填充字段——有0组成的字段，这是为了使整个首部长度是4字节（32）的整数倍。

### TCP可靠传输技术

+ TCP所依赖的IP服务是尽最大努力交付、不可靠的服务。
+ TCP可靠传输技术能够确保一个进程收到的数据流是无差错、无丢失、不重复、不失序的。
+ TCP提供可靠数据传输而使用的方式涉及前面提到的序号、确认、超时重传、滑动传输机制。

#### 流量控制

流量控制是防止发送方发送过快，从而使接收方无法接收。

流量控制是使用一个大小可变的滑动窗口实现的。

TCP流量控制只涉及两个端系统，与网络无关。

![](http://img-blog.csdnimg.cn/20190321164035512.png)

TCP接收方只有一个接收缓冲区：

![](http://img-blog.csdnimg.cn/20190321164615328.png)

应用程序从接收缓冲区读数据的速度可能较慢。因此，发送速率需要匹配接收方应用程序的提取速度。

![](http://img-blog.csdnimg.cn/20190321164956901.png)

lastByetRecvd - lastByteRead ≤ RecvBuffer

RWin = RecvBuffer - [LastByteRecv - LastByteRead]

当LastByteRecv - LastByteRead = RecvBuffer时，缓冲区会被填满，使得RWin的值减小为0；

如接收应用程序能及时从缓冲区中读取到数据，RWin就可以增大，大最大不能超过缓存的大小。即:RWin是可变的。

![](http://img-blog.csdnimg.cn/20190321170540796.png)

+ 发送窗口通常只是发送缓存的一部分；
+ 发送应用程序最后写入发送缓存的字节减去最后确认的字节，就是保留在发送缓冲区中的字节数。

+ 发送缓存用来暂时存放：
    + 发送应用程序传送给发送方TCP准备发送的数据；
    + TCP已发送出但尚未收到确认的数据。

+ 接收缓存用来暂存：
    + 按序到达的、但尚未被接收应用程序读取的数据；
    + 不按序到达的数据。

![](http://img-blog.csdnimg.cn/20190321170540796.png)

发送的有效窗口大小是根据发送缓冲区的大小和发送但未被确认的报文大小的差决定的。

但是发送的窗口大小需要根据接收方滑动窗口的大小进行调整，如果接收方滑动窗口大小小于有效窗口，那么必须调整发送窗口的大小为接收方滑动窗口的大小，否则是有效窗口的大小。

滑动窗口的大小由接收方的接收缓冲区中的可用空间决定。

持续计时器

B向A发送了RWin=0的报文段不就会，B接收缓冲区又有了一些存储空间。于是B向A发送了RWin=400的报文段。然而这个报文段丢失了，则A一直等待收到B发送的非零窗口的通知，而B一直等待A发送数据。

在这里陷入了僵局，如何打破？

+ 只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器（persisting timer）。

+ 若持续计时器设置的时间到期了，就发送一个探测窗口（window proble）报文段（仅携带一个字节的数据）。
+ 对方接收到这个探测报文段时，会发送确认报文段（其窗口字段正式现在的窗口值）。
    + 若窗口值不是0，则死锁的僵局就可以打破了。
    + 若窗口值仍然是0，则收到这个报文段的一方就重新设计持续计时器。（若窗口值总和是0，好周期性发送探测）

### TCP连接管理

+ TCP连接有三个阶段，即：连接建立、数据传送和连接释放。运输连接的管理就是使运输链接的建立和释放都能正常地进行。
+ 连接建立过程中要解决的一下三个问题：
    + 要使每一方都能确知对方的存在。
    + 要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）。
    + 能够对运输实体资源（如缓存大小，连接中的项目等）进行分配。

TCP的连接锦鲤都是采用客户服务器方式。

+ 主动发起连接建立的应用进程叫做客户（client）。
+ 被动等待连接建立的应用进程叫做服务器（server）。

### TCP连接的建立

用三次握手建立TCP连接。

![](http://img-blog.csdnimg.cn/20190321195954227.png)

第一次：A的TCP向B发出连接请求报文段，其首部中的同部位SYN=1，并选择序号seq = x。

第二次：

+ B的TCP收到连接请求报文段口，如同意，则发回确认。
+ B在确认报文中应使SYN = 1，使ACK = 1，其确认号ack = x + 1，自己选择的序号seq = y。

第三次：

+ A收到此报文段后向B给出确认，其ACK = 1，确认号ack = y + 1。
+ A的TCP通知上层应用程序，连接已经建立。
+ B的TCP收到主机A的确认后，也通知其上层应用进程：TCP连接已经建立。

#### 连接释放

![](http://img-blog.csdnimg.cn/20190321204827735.png)

第一次：

+ 数据传输结束后，通信的双方都可释放连接。现在A的应用进程先向其TCP发出连接释放报文段，并停止发送数据，其主动关闭TCP连接。
+ A把连接释放的报文段首部的FIN = 1，其序号seq = u，等待B的确认。

第二次：

+ B发出确认，确认号ack = u + 1，而这个报文段自己的序号seq - v。
+ TCP服务器进程通知高层应用进程。
+ 从A到B这个方向的连接就释放了，TCP连接处于半关闭状态。B若发送数据，A仍要接收。

第三次：

+ 若B已经没有要想A发送的数据，其应用程序就通知TCP释放连接。
+ B向A发送FIN = 1，ACK = 1, seq = w, ack = u + 1的报文段，已经准备号彻底断开连接了。

第四次：

+ A收到连接释放的报文后，必须发出确认。

TCP三次握手建立TCP连接的各状态：

![](http://img-blog.csdnimg.cn/20190321205511353.png)



![](http://img-blog.csdnimg.cn/20190321233948854.png)

MSL（Maximum Segment Lifetime, 最长报文段寿命）指任何报文段被丢弃之前在网络内的最长时间。

+ 作用一，为了保证A发送的最后一个ACK报文段能够到达B。因为这个ACK可能会丢失，从而导致处于LAST-ACK状态的B收不到对应的ACK确认报文。那么当B因为没有收到这个ACK而超时的时候，会重传FIN-ACK，接着A在重传一次确认，并重新启动一个等待计时器。最后客户端A和服务器B都能正常关闭。假设客户端不等待2MSL，而是在发送ACK之后直接释放关闭，一旦这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

+ 作用二，它还可以放置已失效的报文段。客户端在发送一个ACK之后，再经过2MSL，就可以使本连接持续时间内所产生的所有报文段都从网络中消失。从保证本连接后不会还有网络中滞留的报文段去骚扰服务器。


#### TCP的四种计时器

+ 重传计时器
+ 持续计时器
+ 保活计时器
+ 时间等待计时器

保活计时器：

每当服务器收到客户的信息，就将保活计时器复位，超时通常设置2小时，若服务器超过2小时还没有收到来自客户端的信息，就发送探测报文段，若发送了10个探测报文段（每75秒发一个）还没收到响应，则终止连接。

#### TCP的拥塞控制

什么是拥塞控制？

+ 网络资源：链路带宽容量、交换节点中缓存的内容、CPU的处理能力。
+ 拥塞：

    在某段时间内，若对网络中某资源的需求超过了该资源所能够提供的可以部分，网络的性能就要变坏，这种情况叫做拥塞（congestion）。
    
+ 出现资源拥塞的条件：
    + 对资源的需求 > 可用资源

若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。

解决的办法：拥塞控制与流量控制

拥塞控制：

+ 涉及到所有主机和路由器，以及与降低网络性能有关的所有因素，是针对网络资源受限而设置的，是全局问题。
+ 保证网络能够承受现在的网络负荷。
+ 拥塞控制对付的是链路与路由器。

流量控制：

+ 与发送端和接收端两点之间的通信相关，是针对端系统中资源受限而设置的，是局部问题，基于反馈进行控制。
+ 避免发送段的发送量超出接收端的承受能力。
+ 流量控制对付的是主机。

拥塞控制所起的作用：

![](http://img-blog.csdnimg.cn/20190323194025886.png)

+ 拥塞控制CWin（congestion window），或者称为cwnd：是发送端根据自己估计的网络拥塞程度而设置的窗口值。
+ 发送控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减少了，以减少注入到网络中的分组数。

发送窗口的上限值=Min[接收窗口，拥塞窗口]

+ 当RWin < CWin时，接收端的接受能力限制发送窗口的大小。
+ 当RWin > CWin时，则是网络拥塞情况限制发送窗口的最大值。

#### 拥塞控制的方法

+ 慢启动
+ 拥塞避免
+ 快重传
+ 快恢复

慢启动

1. 在主机刚刚开始发送报文段时可以先设置拥塞窗口CWin = 1，即设置为一个最大报文段MSS的数值。
2. 在没收到一个对新的报文段的确认后，将拥塞窗口CWin加1，即增加一个MSS的数值。换句话说：发出（拥塞窗口/MSS）个最大长度的TCP报文段，若都得到确认，拥塞窗口加倍；

![](http://img-blog.csdnimg.cn/20190323214450252.png)

慢启动

1. 连接建好的开始先初始化CWin = 1，表明可以串一个MSS大小的数据。
2. 每当收到一个ACK，CWin++，呈线性上升。
3. 每当过了一个RTT，CWin = CWin × 2;呈指数上升。
4. 还有一个ssthresh是一个上限，当CWin >= ssthresh时，就会进入“拥塞避免算法”。

拥塞避免（Conestion Avoidance）

1. 慢启动不会长久地增加拥塞窗口，当CWin >= ssthresh时，停止使用慢启动算法而改动拥塞避免算法。
2. 拥塞避免算法的思路是让拥塞窗口CWin缓慢的增大，即每经过一个往返时间RTT就把发送方的拥塞窗口CWin加1，而不是加倍，即：每当过一个RTT时，CWin = CWin + 1。使拥塞窗口CWin按线性增长规律缓慢增大。

![](http://img-blog.csdnimg.cn/20190323222124631.png)

当网络出现拥塞时

1. 拥塞窗口不可以无限制地增加。无论在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是有没有按时收到的确认），就要把慢启动门限sshthresh设置为出现拥塞时的发送方窗口值的大小（但不能小于2）。
2. 然后把拥塞窗口CWin重新设置为1，执行满启动算法。


慢启动和拥塞避免

1. 加法增大（也称加性增）

    “加法增大”是指执行拥塞避免算法阶段
，每当过一个RTT时，CWin = CWin + 1，即当收到对所有报文段的确认就将拥塞窗口CWin增加到一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。

2. 乘性减小（也称乘性减）

    “乘性减小“是指不论是在慢启动阶段还是拥塞避免阶段，只要出现一次（即出现一次网络拥塞），就把慢启动门限值ssthresh设置为当前的拥塞窗口值乘以0.5。
    
    当网络频繁出现拥塞时，ssthresh值就下降得很快，以大大减少注入到网络中的分组数。
    
快重传

+ 快重传算法首先要将要求接收方每收到一个失序的报文段后就立即发出重复确认（duplicate ACK）。这样<u>可以让发送方及早知道有报文段没有到达接收方</u>。
+ 发送方只要一连收到三个重复确认就应当立即重传对方尚未接收到的报文段。而不必等待重传计时器到期。
![](http://img-blog.csdnimg.cn/20190323223418780.png)

+ 不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。

快恢复

1. 当发送端收到连续三个重复确认时，就执行“乘法减小”算法，把慢启动门限值ssthresh设置为当前的拥塞窗口乘以0.5。但接下去不执行慢启动算法。
2. 由于发送方在认为网络很可能没有发生拥塞，因此现在不执行慢启动算法，即拥塞窗口CWin现在不设置为1，而是设置为慢启动门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢的线性增大。

![](http://img-blog.csdnimg.cn/20190324115637383.png)
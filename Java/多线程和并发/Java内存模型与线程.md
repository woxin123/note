# Java内存模型与线程

## 硬件的效率与一致性

由于计算机的存储设备与处理器的运算速度有几个数量级的差别，所以现代的操作系统不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来做为内存与处理器的缓冲：讲运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步会内存，这样就无须等待缓慢的内存读写了。

基于高速缓存的存储交互系统解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了另一个问题：缓存一致性（Cache Cohreence）。在多处理机系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存（Main Menory），如图所示：

![](http://img.mcwebsite.top/20190907143818.png)

当多个处理器的运算任务都涉及同一块内存区域时，将可能导致各自的缓存不一致，如果发生这种情况，那么同步回主内存时以谁的缓存为准呢？为了解决缓存一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，类似的协议有 MSI、MESI（Illionis Protocol）、MOSI、Synapse、Firefly 及 Dragon Protocol 等。内存模型，可以理解为特定的操作协议下，对特定的内存或高速缓存进行读写访问的抽象。不通架构的机器可以拥有不一样的内存模型，而 Java 虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存的访问操作有很高的可比性。

除了增加高速缓存外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后讲乱序执行的结果重组，保证该结果与顺序执行的结果时一致的，但并不保证各个语句计算的先后顺序与输入的代码一致，因此，如果存在一个计算任务依赖与另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后执行顺序来保证。与处理器乱序执行优化类似，Java 虚拟机的及时编译器中也有类似的指令重排序（Instruction Recorder) 优化。

## Java 内存模型

Java 虚拟机中试图定义一种 Java 内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统之间的内存访问差异，以实现让 Java 程序在各种平台都能达到一致的内存访问效果。在此之前，主流程序语言（如 C/C++ 等）直接使用物理硬件和系统的内存模型。因此，会在不通的平台上的内存模型有差异，有可能导致程序在一套平台上并发完全正常，而在另一套平台上并发的访问却经常出错，因此在某些场景就必须针对不通的平台来编写程序。

### 主内存和工作内存

Java 内存模型的主要目标时定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然也就不会存在竞争问题。为了获得更好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。

Java 内存模型规定了所有的变量都存在主内存（Main Memory）中（虚拟内存的一部分），每条线程还有自己的工作内存（Work Meomory），线程的工作内存中保存了被线程使用到的变量主内存的父辈拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程也无法直接访问对方工作内存中的变量，线程、主内存、工作内存三者的交互如下图所示：

![](http://img.mcwebsite.top/20190907162429.png)

### 内存间交互操作

关于内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了以下 8 种操作来完成，虚拟机实现必须保证下面提及的每一个操作都是原子的、不可再分的。

+ lock（锁）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。

+ unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

+ read（读取）：作用于主内存的变量，它把一个变量的值从主内存得到的变量值放入工作内存中，以便随后的 load 动作持用。

+ load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的副本中。

+ use（使用）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值传递给执行引擎，每当虚拟机遇到一个需要使用的变量的值的字节码指令时才会执行这个操作。

+ assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将执行这个操作。

+ store（存储）：作用于工作内存的变量，它把内存中一个变量的值传递给主内存中，以便以后的 write 操作使用。

+ write (写入)：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

### 对于 volatile 型变量的特殊规则 
# 计算机组成原理

## 第二章 运算方法和运算器

移码通常用于表示浮点数的阶码。对于字长是n+1位的整数，假定定点整数移码形式为  $x_0x_1x_2…x_n$ 时，对于定点整数的移码的传统定义是：

$$ [X]_移 = 2^n + x s \qquad 2^n  > x \geq -2^n$$

**移码就是在真值的基础上加上一个常数，这个常数被称为偏移值，相当于x在数轴上的正向一中了若干单位，这就是”移码“一词的由来。**

浮点数的一般表示形式：

一个机器浮点数由阶码和尾数即符号位组成（尾数：用定点小数表示，给出有效整数的位数决定了浮点数的表示精度；阶码：用整数形式表示，指明了小数在数据中的位置，决定了浮点数的表示范围）：

![image-20190703161510256](/Users/mengchen/Library/Application Support/typora-user-images/image-20190703161510256.png)

规格化浮点数

一个浮点数的表示可以不唯一。所以就需要有规格化。例如，$(1.75)_{10}$可以表示成 $0.0111×2^2$，$0.111×2^1$等等。

为了提高数据的表示精度，当尾数的值不为0时，尾数域的最高有效位应为1，否则要修改阶码同时移动小数点的方法，这种方法称为浮点数的规格化表示。

当浮点数的尾数的值为 0，或者当阶码的值遇到比它能表示的最小值还小时，计算机都把该浮点数看成零值，称为机器零。通常为了保证浮点零的唯一性，需将阶码和尾数均置为零。

二进制规格化浮点数的尾数的绝对值应在：

$$ \frac{1}{2}\leq |M| < 1 $$

当尾数用原码表示时，规格化尾数的最高位总和1，因此表示范围：

$$ \frac{1}{2} \leq M < 1 \qquad -1 < M \leq -\frac{1}{2} $$

尾数应有格式形如：0.1xxxxxx   1.1xxxxx

IEEE754标准

目前的计算机基本采用的都是IEEE754标准，其格式如下所示：

![](http://img.mcwebsite.top/blog/img/20190703163942.png)

![](http://img.mcwebsite.top/blog/img/20190703163958.png)

在IEEE754标准格式表示的32位浮点数中，

S: 浮点数的符号位，1位，0表示整数，1表示负数

M: 尾数，32位，纯小数，采用原码来表示。

E:阶码，8位，采用移码方式来表示正负指数。将浮点数的指数真值e编程阶码E时，应将指数e加上一个固定的偏移值127(0111 1111) 即 E = e + 127。

IEEE754 标准中，一个规格化的32位浮点数x的真值可表示为

$$ x = (-1)^s \times (1.M) \times 2^{E-127} \qquad e = E - 127 $$

在32位浮点数表示中，要出去E用全0和全1 $(255)_{10}$ 表示零和无穷大的特殊情况，指数的偏移值不选128（1000 0000），而选127（0111 1111）。

对于规格化浮点数，E的范围变为1到254，真正的指数值e则为-126到+127。

IEEE754 标准32位浮点数的表示范围：

最大正数 $+[1+(1-2^{-23})] \times 2^{127}$ 

![](http://img.mcwebsite.top/blog/img/20190703173144.png)

最小正数 $ +(1.0) \times 2^{-126} $

![](http://img.mcwebsite.top/blog/img/20190703173540.png)

最大负数 $-1 \times 2^{-126}$

![](http://img.mcwebsite.top/blog/img/20190703173644.png)
零 0

![](http://img.mcwebsite.top/blog/img/20190703173713.png)

正负无穷

![](http://img.mcwebsite.top/blog/img/20190703173742.png)

### 2.2 定点加法、减法运算

#### 补码加法

负数用补码表示后，可以和正数一样来处理。这样，运算器李只需要一个加法器就可以了，不必为了负数的加法运算，在配一个减法器，补码加法的公式是：

$$ [x]_补  + [y]_补 = [x + y]_补$$

#### 补码减法

补码减法的公式：

$$ [x - y]_补 = [x]_补 - [y]_补 = [x]_补 + [-y]_补 $$

从$[y]_补$求$[-y]_补$ 的法则是：对$[y]_补$ 包括符号位“求反且末尾加1“，即可得到 $[-y]_补$ 。写成运算表达式，则为

![](http://img.mcwebsite.top/blog/img/20190703175753.png)

#### 溢出概念与检测方法

在定点小数机器中，数的表示范围为|x| < 1. 在运算过程中出现大于1的现象，称为”溢出“。在定点机器中，正常情况时，溢出是不允许的。

![](http://img.mcwebsite.top/blog/img/20190703205625.png)

两个整数相加，结果大于机器所能表示的最大整数，称为上溢。而两个负数相加，结构小于及其所能表示的最小负数，称为下溢。

为了判断 ”溢出“是否发生，可采用检测方法。

**第一种溢出检测方法是采用单符号法。** 当最高有效位产生进位而符号位无进位的时候，产生上溢；当最高有效位进位而符号位无进位时，产生下溢。

**第二种方法是采用双符号位法，**这称为”变形补码“或”模4补码“，从而可使模2补所能表示的数的范围扩大一倍。

若定点小数补码形式为 $x_0x_1x_2…x_n$ ，则”变形补码“或”模4补码“表示的定义是：

![image-20190704000128341](/Users/mengchen/Library/Application Support/typora-user-images/image-20190704000128341.png)

采用变形补码后，

+ 大于1的整数，均表示为：$00.x_1x_2…x_n$
+ 小于-1的负数，均表示为：$11.x_1x_2…x_n$

如果两个数字相加后，其结果的符号位出现”01“或者"10"两种组合时，表示发生溢出。

由于两个绝对值小于1的数相加，其结果不会大于2，所以最高符号位表示结果的正确符号。



## 存储器

只读存储器 ROM

随机读写存储器 RAM

字存储单元即存放一个机器字地址的存储单元，相应的字节地址称为字地址。一个机器字可以包含数个字节，所以一个存储单元也可包含数个能够单独编制的字节地址。






# 数据库索引

索引是为了提高数据库提高查询速度而建立的。

在Mysql的InnoDB存储引擎中支持以下几种常见的索引：

+ B+树索引
+ 全文索引
+ 哈希索引

B+树索引就是传统意义上的索引，这是目前关系型数据库中查找最为常用和最为有效的索引。B+树索引的构造类似于二叉树，根据键值（Key Value）快速查找到数据。

>B+树的B不是代表二叉（binary），而是代表平衡树（balance），因为B+树从最早的平衡二叉树演化而来，但是B+树不是一个二叉树。

另一个上上被忽略的问题是：B+树索引并不能找到一个给定键值的具体行。**B+树索引能找到的只是被查找数据行所在的页**。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到想要的数据。

## 1. 数据结构与算法



## 2. B+树索引

B+树索引的本质就是在B+树在数据库中的实现。但是B+树索引在； 数据库中有一个特点是高扇出性，因此在数据库中，B+树的高度一般都在2~4层，这也就是说查找某一键值的行记录时最多只需要2到4次IO。

数据库中的B+树索引分为聚集索引（clustered inex）和辅助索引（secondary index），但是不管是聚集索引还是辅助索引，其内部都是B+树，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。

注：**辅助索引有时也称为非聚集索引**。

### 2.1 聚集索引

之前已经介绍过，InnoDB存储索引是按照索引组织表，即表中的数据按照主键序存放，而**聚集索引（clustered index）就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的行记录数据**。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树一样，每个数据页都通过一个双向链表来进行连接。

由于实际的数据页只能按照一颗B+树进行排序，因此每张表只能拥有一个聚集索引。因为聚集索引能够在B+树索引的叶子节点中直接找到数据。此外，**由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围地查询**。查询优化器能够快速发现某一段范围的数据页需要扫描。

### 2.2 辅助索引（非聚集索引）

对于辅助索引（Secondary Index，也称为非聚集索引），叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行还包含一个书签（bookmark）。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎是索引表组织表，**因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键**。

辅助索引的存在并不影响数据在； 聚集索引中的组织，因此每张表上可以有多个辅助索引。当通过辅助索引来寻找数据的时候，InnoDB存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后通过主键索引来找到一个完整的行记录。举例来说，如果一颗高度为3的辅助索引树中查找数据，那需要对这棵辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到承恩完整的行数据所在的页，因此一共需要6次逻辑IO访问以得到最终的一个数据页。

### 2.3 Cardinality值

并不是在所有查询条件中出现的列都需要添加索引。对于什么时候添加B+树索引，一般经验是，在访问表中很少一部分使用B+树索引才有意义。对于性别字段、地区字段、类型字段，它们可取值的范围很小，称为低选择性。如：

```sql
SELECT * FROM student WHERE sex = 'M';
```

按性别进行查询，可取值的范围一般只有'M'、'F。因此上述SQL语句得到的结果可能是该表50%的数据（假设男女比例1:1），这时添加B+树索引是完全没有必要的。相反，如果某个字段的取值范围很广，几乎没有重复，即属于高选择性，则此时使用B+树索引是最合适的。例如，对于姓名字段，基本上在一个应用中不允许重名的出现。

怎样查看索引是否是高选择性的呢？可以通过`SHOW INDEX`结果中的`Cardinality`来观察。Cardinality值非常关键，表示索引中不重复记录数量的预估值。同时需要注意的是，Cardinality是一个预估值，而不是一个准确值，基本上用户也不可能得到一个准确的值。在实际应用中，Cardinality/n_rows_in_table应尽可能地接近1。如果非常小，那么用户需要考虑是否还有必要创建这个索引。故在访问高选择性属性的字段并从表中取出很少一部分数据时，对这个字段添加B+树索引是非常有必要的。

### 2.4 联合索引

联合索引是指对表上的多个列进行索引。前面说的情况都是只对表上的一个列进行索引。联合索引的创建方法与单个索引的方法一样，不同之处在于有多个索引列。例如，一下代码创建了一张t表，并且索引inx_a_b是联合索引，联合的列为（a，b）。

```sql
CREATE TABLE t (
    a INT,
    b INT,
    PRIMARY KEY (a),
    KEY idx_a_b (a, b)
) ENGINE=INNODB
```

从本质上来说，联合索引也是一颗B+树，不同的是联合索引的键值的数量不是1，而是大于等于2。假定两个键值的名称分别为a，b，如下图所示：

![](https://img-blog.csdnimg.cn/20190407230320843.png)

从上图可以观察到多个键值的B+树情况。其实和之前讨论的单个键值对的B+树并没有什么不同，键值对都是排序的，通过叶子节点可以逻辑上顺序地读出所有数据，就上面的例子来说，即（1, 1）、（1, 2）、（2, 1）、（2, 4）、（3, 1）、（3, 2），数据库（a, b）的顺序进行存放。

因此，对于查询`SELECT * FROM TABLE WHERE a = xxx AND b = xxx`，显然是可以使用（a, b）这个联合索引的。对于单个的a列查询`SELECT * FROM TABLE WHERE a = xxx AND b = xxx`，也可以使用（a, b）索引。但对b列的查询`SELECT * FROM TABLE WHERE a = xxx AND b = xxx`，则不可以使用这棵B+树索引。可以发现叶子节点上的b值为1、2、1、4、1、2，显然不是排序的，因此对于b列的查询使用不到（a, b）的索引。

### 2.5 覆盖索引

InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录包含的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。

对于InnoDB存储引擎的辅助索引而言，由于其包含了主键，因此其叶子节点存放的数据为（primary key1，primary key2, ..., key1, key2, ...）。例如，下列语句都可仅使用一次辅助联合索引来完成查询。

```sql
SELECT key2 FROM table WHERE key1=xxx;
SELECT primary key2, key2 FROM table WHERE key1=xxx;
SELECT primary key1, key2 FROM table WHERE key1=xxx;
SELECT primary key1, primary key2, key2 FROM table WHERE key1=xxx;
```

覆盖索引的另一个好处就是对某些统计而言，InnoDB存储引擎并不会通过查询聚集索引来进行统计。而是会选择通过辅助索引来统计。总之能通过辅助索引查询到结果，就不会使用聚集索引查询。
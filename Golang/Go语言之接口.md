# Go语言之接口

从概念上讲，一个接口类型的值（简称接口值）其实有两部分：一个具体的类型和该类型的值。两者分别称为接口的动态类型和动态值。

对于 Go 语言这样的静态类型语言，类型仅仅只是一个编译时的概念，所以类型不是一个值。在我们的概念模式中，用类型描述符来表述。

如下的四条语句中，变量w有三个不同的值（最开时的和最后的时同一个值）：

```go
var w write
w = os.Stdout
w = new(*bytes.Buffer)
w = nil
```

接下来我们详细地看在每条语句后 w 的值和相关的动态行为。第一个语句声明了 w :

```go
var w io.Writer
```

在 Go 语言中，变量在申请后就会进行初始化零值，接口也是如此。接口的零值就是把动态类型和值都设置为 `nil`。

一个接口值是否是 `nil` 取决于它的动态类型，所以现在这是一个 `nil` 接口值。可以使用 `w == nil` 或者 `w != nill` 来检测一个接口值是否是 `nil`。调用一个 `nil` 接口的任何方法都会导致崩溃：

```go
w.Write([]bytes("hello")) // 崩溃: 对空指针取引用值
```

第二个语句把一个 `*os.File` 类型的值赋给了 w :

```go
w = os.Stdout
```

这次的赋值把一个具体类型隐式转换为一个接口类型，它对应的显示转换 `io.Writer(os.Stdout)` 等价。不管这种类型的转换是隐式的还是显示的，它都可以转换操作数的类型和值。接口值的动态类型设置为指针类型 `*os.File` 的类型描述符，它的动态值设置为 `os.Stdout` 的副本，即指向一个代表进程的标准输出的 `os.File` 类型的指针。

调用该接口值的方法，会实际调用 `(*os.File).Write` 方法，即写入 "hello"。

```go
w.Write([]byte("hello"))
```

一般来讲，在编译时我们无法知道一个接口的动态类型会是什么，所以通过接口来做调用必然需要使用动态分发。编译器必须生成一段代码来从类型描述符拿到名为 `Write` 的方法地址，在间接调用该方法的地址。调用的接受者就是接口值的动态值，即 `os.Stdout` ，所以效果与直接调用等价：

```go
os.Stdout.Write([]byte("hello"))
```

第三个语句把一个 `*bytes.Buffer` 类型的值赋值给了接口值：

```go
w = new(bytes.Buffer)
```

动态类型是 `*bytes.Buffer`，动态值现在则是一个指向新分配缓冲区的指针。

调用 `Write` 方法的机制和第二个语句一致：

```go
w.Write([]byte("hello") // 把 "hello" 写入 bytes.Buffer
```

这次，类型描述符是 `*bytes.Buffer`，所以调用的是 `(*bytes.Buffer).Write` 方法，方法的接受者是缓冲区的地址。调用该方法会追加 "hello" 到缓冲区。

最后，第四个语句把 `nil` 赋值给了接口值：

```go
w = nil
```

这个语句把动态类型和动态值都设置为 `nil`，把恢复到了它刚声明的状态。

一个接口的值可以指向多个任意大的动态值。比如，`time.Time` 类型可以表示一个时刻，它是包含在几个非导出字段的接口。如果从它创建一个接口值：

```go
var x interface{} = time.Now()
```

从理论来讲，无论接口值多大，它永远在接口的内部（当然这只是一个理论模型；实际是很不同的）。

**接口的值可以使用 `==` 和 `!=` 操作符来比较。如果两个接口的值都是 `nil` 或者二者的动态类型完全一致并且二者的动态值相等（使用动态类型的 `==` 来做比较），那个两个接口值相等。** 因为接口值是可比较的，所以它们可以作为 `map` 也可以作为 `switch` 语句的操作数。

需要注意的是，在比较两个接口值时，如果两个接口的动态类型一致，但想对应的动态值是不可比较的（如 `slice` )，那么这个比较会以崩溃的方式失败。

```go
var x interface{} = []int{1, 2, 3}
fmt.Println(x == x) // 宕机：试图比较不可比较的类型 []int
```

当发生错误或者调试时，能拿到接口的动态类型是非常有作用的。可以使用 `fmt` 包的 `%T` 来实现这个需求。

```go
var w io.Writer
fmt.Println("%T\n", w)  // "<nil>"

w = os.Stdout
fmt.Println("%T\n", w)  // "*os.File"

w = new(bytes.Buffer)   // "*bytes.Buffer"
fmt.Println("%T\n", w)
```

在内部实现中，`fmt` 利用反射拿到接口动态类型的名称。

**注意：含有空指针的非空接口**

空的接口（其中不包含任何信息）与仅仅是动态值不同的接口是不一样的。这种微妙的区别让人非常迷惑。

考虑如下程序，当 debug 设置为 true 时，主函数收集 f 的输出到缓冲区中：

```go
const debug = true

func main() {
  var buf *bytes.Buffer
  if debug {
    var buf = new(bytes.Buffer) // 启动输出日志
  }
  f(buf)  // 注意：微妙的错误
  if debug {
    // ... 使用 buf...
  }
}

// 如果 out 不是 nil，那么会向其中写入输出数据
func f(out io.Writer) {
  // ...其他代码...
  if out != nil {
    out.Write([]byte("done\n"))
  }
}
```

当设置 debug 为 flase 时，我们会觉得仅仅是不再收集日志，但实际上会导致程序在调用 `out.Write` 时崩溃：

```go
if out != nil {
  out.Write([]byte("done\n")) // 宕机：对空指针的引用
}
```

当 main 函数调用 f 时，它把一个类型为 `*bytes.Buffer` 的空指针赋值给了 `out` 参数，所以 `out` 的动态值确实为空。但它的动态类型是 `*bytes.Buffer` ，这表示 `out` 是一个包含了空指针的非空接口，所以防御性检查 `out != nil` 仍然是 true 。

正如前面说的，动态分发机制决定了我们肯定会调用 `(*bytes.Buffer).Write` 方法，只不过这次接受者为空。对于某些类型，比如 `*os.File` ，控制是合法的，但对于 `*bytes.Buffer` 则不行。方法尽管被调用了，但在尝试访问缓冲区时崩溃了。

## 类型断言

类型断言一个作用在接口上的操作，写出来类似于 `x.(T)` ，其中 x 是一个接口类型的表达式，而 T 是一个类型（称之为断言类型）。类型断言会检查作为操作数的动态类型是否满足指定的断言类型。

这儿有两个可能。首先断言类型 T 是一个具体的类型，那么类型断言就会检查 x 的动态类型是否就是 T 。如果检查成功，类型断言的结果就是 x 的动态值，类型当然就是 T 。换句话说，类型断言就是用来从它的操作数中把具体的类型提取出来的操作。如果检查失败，那么操作会崩溃。比如：

```go
var w io.Writer
w = os.Stdout
f := w.(*os.File)       // 成功：f == os.Stdout
c := w.(*bytes.Buffer)  // 失败：接口持有的是 *os.File，不是 *bytes.Buffer
```

其次，如果断言类型 T 是一个接口，那么类型检查 x 的动态类型是否又满足 T 。如果检查成功，动态值并没有提取出来，结果仍然是一个接口值，接口值的类型和值部分也没有变更，只是结果的接口类型为 T 。换句话说，类型断言就是一个接口表达式，从一个接口类型变为拥有另外一套方法的接口（通常方法的数量是增多），但保留了接口中的动态类型和动态值部分。

如下面的类型断言代码中，w 和 rw  都持有 `os.Stdout` ，于是所有的对应的动态类型都是 `*os.File` ，但 w 作为 `io.Writer` ，而暴露了它的 `Read` 方法。

```go
var w io.Writer
w = os.Stdout
rw := w.(io.ReadWrite)  // 成功：*os.File 有 Read 和 Write 方法

w = new(ByteCounter)
rw = w.(io.ReadWrite)   // 崩溃：*ByteCounter 没有 Read 方法
```

